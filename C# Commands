In C#, we can print stuff to the screen using the Write or WriteLine command:
int myVariable = 100;
int woo = 5;
Console.WriteLine("Test variable: {0} {1}", myVariable);	// Prints out: "Test variable : 100 5"

Input in C# is done using the ReadLine command, where the input must be stored as a string variable:
string input;
input = Console.ReadLine();

After the user inputs the data, we need to parse it to the type of variable we will actually use.

We use the Split method on a string to create an array of strings:
string[] inputs = input.Split(',');

After generating the array of inputs, we can, for example, parse those further into other types:
int numbers[];
for(int i=0; i<numberOfInputs; i++){
	if(!Int32.TryParse(inputs[i], out numbers[i])){
		Console.WriteLine("The input {0} isn't a number!", inputs[i]);
		return false;
	}
}

As shown here, the Int32.TryParse(string, int) function returns true if the parsing was successful, and false if it wasn't.


Console.WriteLine("Text {0} {1}", variable_0, variable 1);	// Prints text out
Console.ReadLine();						// Reads a line and returns it as a string
STRING.Split('CHAR');						// Splits a string into an array of strings separated by CHAR
Int32.TryParse(string SOURCE, out int DESTINATION)		// Parses string into an int, returns false if it fails


TYPE testVar = BOOL_FUNCTION ? RES_1 : RES_2			// Makes testVar=RES_1 if the condition is true, or RES_2 if false

foreach(TYPE X in COLLECTION){ ... }				// For loop with one iteration for every member of the collection

public TYPE testVar { get; set; }				// Creates a getter and setter for testVar in some class

Interfaces are defined like classes. They are used to inherit from more than one abstract class (or, in this case, interface):
interface Test{ ... }
interface Test2 { ... }
class myClass : Test, Test2 { ... }
