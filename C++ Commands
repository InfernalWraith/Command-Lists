Comments in C++ can be made by using // for a single line or /*  */ for a multi-line comment:

//This is a single line comment

/* This is a 
multi-line comment */
________________________________________________________________________________________________________________________________
In order to make life easier and use pre-existing functions, we need to include the libraries which contain them like so:

#include <iostream>		// Contains the basic functions such as printing text and data input
#include <vector>		// Contains functions for working with vectors
#include <string>		// For working with strings
#include <fstream>		// Used for working with files
________________________________________________________________________________________________________________________________
Every C++ program needs to contain a function called "main"

int main(){
	// YOUR CODE HERE
	return 0;
}

The main function needs to end with the command "return 0" which says the program executed without any problems.
If a value other than 0 returns, it usually means the program finished abruptly due to some kind of error.
________________________________________________________________________________________________________________________________
We can initialize variables and designate which kind of value they can be like so:

int Variable1;
float var2;				// For real numbers, accurate to around the 6th decimal
const double PI = 3.14159;		// "const" means the variable has a fixed value and can't be altered, double>float
char letter = 'A';			// For characters
bool works = true;			// Is also equal to 1;
bool doesnt_work = false;		// Is also equal to 0;

We can also change one type of variable into another like so:

(int) 3.14				// C-style notation, this is equal to 3
int(3.14)				// Same effect, C++ functional notation
static_cast<int> 3.14			// Same effect, but the safest when it comes to making a program multi-platform
________________________________________________________________________________________________________________________________
Library <iostream>:

cout << "Text" << VARIABLE;		// Prints text, variables and other things to the screen
cout << endl;				// OUTPUT STREAM OBJECT, inserts a new line
setw(INTEGER);				// OUTPUT STREAM OBJECT, allocates the specified width for the first next output only
cout.width(INTEGER);			// Is added as a modifier right on the "cout" and it sets the width for ALL outputs
setfill(CHARACTER);			// OUTPUT STREAM OBJECT, fills the remaining space with the specified character
setprecision(INTEGER);			// OUTPUT STREAM OBJECT, makes the output precise to the specified amount
fixed					// OUTPUT STREAM OBJECT, makes setprecision print out a fixed amount of digits


// NOTE: If the input isn't the same type as the variable , cin is set to FALSE then and can be tested with if(!cin)
cin >> VARIABLE;			// Waits for input, storing it in the variable we designated
cin.clear();				// Resets the value of cin in case its value was changed
cin.ignore(INTEGER, CHARACTER);		// Clears INTEGER amount of characters from the buffer, or until it clears CHARACTER
ws;					// INPUT STREAM OBJECT, extracts all whitespace characters
cin.peek();				// INPUT STREAM OBJECT, returns the next character in the input without extracting it

// NOTE: getline should be used when dealing with string input, and we should always call the cin.ignore() command before it!
getline(cin, VARIABLE);			// Grabs the input regardless of whitespace characters and stores it in the variable
cin.getline(STRING, sizeof STRING);	// To make sure there's enough space in our string for the input

for(int i=0; i<10; i++)	//CODE		// Standard foor loop that loops 10 times in this case
while(CONDITION) //CODE			// Standard while loop;
________________________________________________________________________________________________________________________________
Library <cmath>:

sin(NUMBER);			// Sine
asin(NUMBER);			// Inverse sine
cos(NUMBER);			// Cosine
acos(NUMBER);			// Inverse cosine
tan(NUMBER);			// Tangent
atan(NUMBER);			// Inverse tangent
log(NUMBER);			// Natural logarithm
log10(NUMBER);			// Common logarithm
pow(NUMBER, EXPONENT);		// Raise NUMBER to the power of EXPONENT
sqrt(NUMBER);			// Square root
ceil(NUMBER);			// Round up
floor(NUMBER);			// Round down
abs(INTEGER);			// Absolute value of an integer
fabs(NUMBER);			// Absolute value of a real number
________________________________________________________________________________________________________________________________
Library <vector>:

vector<TYPE> NAME(NR_OF_ELEMENTS, DEFAULT)	// Creates a vector with the specified number of elements and default value
VECTOR.begin();					// Returns an iterator at the first element of the specified vector
begin(VECTOR);					// Returns an iterator at the first element of the specified vector
rbegin(VECTOR);					// Returns a reverse iterator at the first element of the specified vector

VECTOR.end();					// Returns an iterator at the past-the-end element of the specified vector
end(VECTOR;					// Returns an iterator at the past-the-end element of the specified vector
rend(VECTOR);					// Returns a reverse iterator at the past-the-end element of the vector

VECTOR.push_back(VALUE);			// Adds the specified value or variable past the end of the vector (Size++)
VECTOR.size();					// Returns the size of the vector
VECTOR.resize(INTEGER);				// Resizes the vector to the specified amount of elements
VECTOR.insert(ECTOR.begin() + X, VALUE);	// Inserts a certain value or variable to the x-th spot in the vector
VECTOR.erase(VECTOR.begin() + X);		// Erases the x-th element of the vector and sorts the vector
VECTOR.swap(OTHER_VECTOR);			// Swaps the elements of the two vectors of the same type, but sizes may differ

All of the above also works for the library <deque>, with the added bonus of being able to use:

DEQUE.push_front(VALUE);			// Adds the specified value or variable to the front of the deque

However, while vectors sort their elements in a continous block, a deque's memory is fragmented and therefore we shouldn't
use pointer arithmetic while working with deques.
We can also nest vectors in vectors for 2D or even 3D+
vector<vector<int>> my_vector(5, vector<int>(3, 1));	// Creates a 5x3 matrix whose elements have the default value set to 1
________________________________________________________________________________________________________________________________
Library <complex>:

complex<TYPE> NAME(REAL, IMAGINARY);		// Initializes a complex number of the given type and sets its Re and Im values
COMPLEX.real(X);				// Sets the real value of a complex number to X
COMPLEX.real();					// Returns the real value of a complex number
COMPLEX.imag(X);				// Sets the imaginary value of a complex number to X
COMPLEX.imag();					// Returns the imaginary value of a complex number
abs(COMPLEX);					// Returns the absolute value of a complex number
arg(COMPLEX);					// Returns the argument (phase angle) of a complex number
polar(MODULUS ,PHASE_ANGLE);			// Returns the complex number with the given parameters (Re=ρ*cosΘ ; Im=ρ*sinΘ)
conj(COMPLEX);					// Returns the conjugated version of a complex number [Im *= (-1)]
________________________________________________________________________________________________________________________________
Library <string>:

string NAME;					// Initializes a string
STRING.substr(START, LENGTH);			// Returns a part of the string from the starting position to start+length
STRING.size();					// Returns the length of the string
STRING.length();				// Returns the length of the string
________________________________________________________________________________________________________________________________
Library <cstring>:

strcmp(STR1, STR2)				// Compares STR1 to STR2 and returns <0 (STR1 is lower), 0 (equal), >0 (greater)
strcpy(DESTINATION, SOURCE);			// Copies the content from the source to the destination
strlen(s);					// Returns the length of the string
________________________________________________________________________________________________________________________________
Lambda functions:

Lambda functions are nameless functions which we form and use on the spot. They are formed inside the main function.
Lambda functions are written like so:

[](PARAMETERS){ CODE }

If we want to capture a variable that's outside of the lambda function, we can just put it inside the square brackets.
[VAR] is treated like a constant inside the function, while [&VAR] can be modified and affects the variable outside the function
[=] captures all the variables as constants, while [&] captures all variables by reference 
[&, a, b] is a mixed example, as well as [=, &a, &b]
Lambda functions which "capture" variables are called "lambda closures" or just "closures"

Closures can't be passed as parameters to functions which take regular functions as parameters.
Pointers to normal functions can't point to closures.
Bearing this in mind, we can create special pointers to them called polymorphic function wrappers in the library <functional>:
function<int(int)> NAME		// We can put this in a function's prototype so it can accept closures too
________________________________________________________________________________________________________________________________
Comparative functions:

There are many examples of functions in C++ where we can compare things based on the criteria we choose.
Essentially, we form our own custom functions which must return a bool (a value that is either true or false)
After that, we put our function as a parameter while calling the comparative function.
________________________________________________________________________________________________________________________________
Throwing exceptions and <stdexcept>:

We can throw exceptions in C++ by using the try-catch block:

try{
	//CODE
} catch (EXCEPTION_TYPE EXCEPTION_NAME){
	//CODE
} catch (OTHER_EXCEPTION_TYPE OTHER_EXCEPTION_NAME){
	//OTHER CODE
}

This makes the program try to work with the code we passed it in the "try" block, and if an exception is thrown, it's handled
in the "catch" block, where we specify what kind of exception we want to catch and therefore handle it accordingly.
We can have multiple "catch" blocks under a single "try" block, as seen above.
________________________________________________________________________________________________________________________________
Library <algorithm>:
This library contains many useful and time-saving functions, many of which can take custom functions as parameters.

for_each(BEGIN, END, FUNCTION)		// Applies the function to each element enclosed in the block
max_element(BEGIN, END)			// Returns the pointer to the maximal element in the block
max_element(BEGIN, END, FUNCTION)	// Returns the pointer to the maximal element in the block with regard to the function
min_element(BEGIN, END)			// Returns the pointer to the minimal element in the block
min_element(BEGIN, END, FUNCTION)	// Returns the pointer to the minimal element in the block with regard to the function
count(BEGIN, END, ELEMENT)		// Returns how many times the element is found in the block
count_if(BEGIN, END, FUNCTION)		// Returns how many elements return TRUE when passed to the function
remove_copy_if(BEGIN, END, LOCATION)	// Copies all elements to the location while removing duplicates
transform(BEGIN, END, LOC, FUNCTION)	// Applies the function to all elements in the block and puts them in the location
find
find_if
________________________________________________________________________________________________________________________________
Library <utility>:

swap(VAR1, VAR2)			// Swaps the contents of VAR1 and VAR2
________________________________________________________________________________________________________________________________
Pointers:

Library <memory>:

shared_ptr<TYPE> NAME			// Creates a shared pointer with the type "TYPE" and the name "NAME"
make_shared<TYPE>(VALUE);		// Like "new" but creates a shared pointer to the dynamically allocated memory
shared_ptr<TYPE> NAME(new TYPE[ARRAYLENGTH], [](TYPE *p) { delete[] p; });	// How to make a shared pointer array
unique_ptr<TYPE> NAME			// Creates a unique pointer with the type "TYPE" and the name "NAME"
unique_ptr<TYPE> P2(std::move(P1));	// How to transfer one unique pointer to the other (the first becomes a null-pointer)
unique_ptr<TYPE[]> p(new TYPE[LENGTH]);	// Creates a unique pointer to an array with the length "LENGTH"

NEW_POINTER(SMART_POINTER.get());	// Creates a "dumb" pointer from a smart pointer
SMART_POINTER = nullptr;		// Used to delete the dyn. alloc. content of a smart pointer (bc "delete" doesn't work)
________________________________________________________________________________________________________________________________
Library <iterator>:
Iterators are very similiar to pointers. They point to an object and can be dereferenced.
They don't exactly possess all the features a pointer does, but they can navigate fragmented containers with ease.
Iterators can be output iterators, input iterators, forward iterators, bidirectional iterators and random access iterators.

VARIABLE::iterator NAME			// Creates an iterator pointing to the variable
advance(ITERATOR, NUMBER)		// Advances the iterator the amount of times specified
distance(IT1, IT2)			// Measures the distance between 2 iterators by incrementing IT1 until it becomes IT2
CONST_VARIABLE::const_iterator NAME	// Creates an iterator to a constant variable, can't use a normal iterator
VARIABLE::reverse_iterator NAME		// Creates a reverse iterator, in which everything is reversed
VARIABLE::const_reverse_iterator NAME	// Creates a reverse iterator to a constant variable
CONTAINER.rbegin();			// Returns a reverse iterator to the beginning of the container
CONTAINER.rend();			// Returns a reverse iterator to the end of the container
back_inserter(COLLECTION);		// While using this iterator to add elements, they are inserted instead of copied
front_inserter(COLLECTION);		// Works only for containers which support "push_front"
inserter(CONTAINER, ITERATOR);		// Function which is passed to other function, returns an inserter at the ITERATOR
ostream_iterator<TYPE> NAME(cout, CHAR)	// Output stream iterator which prints "xyzCHAR" for the command "NAME += xyz"
________________________________________________________________________________________________________________________________
Library <list>:
Lists are containers whose elements aren't continuous, but where every element contains a pointer to its "adjacent" elements.
Lists use bidirectional iterators and don't support indexing, but they're efficient for using "insert" and "erase" functions.
In fact, their iterators can only be incremented/decremented by 1 at a time, making navigating through lists a bit tricky.

list<TYPE> NAME{elements}		// Creates a list
ITERATOR = SOME_LIST.erase(ITERATOR); 	// How to safely delete an element of a list without the risk of a dangling iterator
LIST.sort()				// Sorts the elements of a list low to high, we can also pass it a custom sort function
_______________________
Library <forward_list>:
The elements of forward lists only contain a pointer to the element "after" it, meaning they can only use ++ and not --

forward_list<TYPE> NAME			// Creates a forward list
ITERATOR = FW_LIST.before_begin;	// Creates an iterator which points to an imaginary element before the first one
FW_LIST.insert_after(IT, VALUE)		// Inserts the VALUE at the spot just after the iterator IT
________________________________________________________________________________________________________________________________
Library <set>:
Sets are containers whose elements are automatically sorted to go from lowest to highest.
Normal sets do not contain duplicates, but multisets do. They cannot be indexed, since their elements don't have a position.
Sets should be used when we need to quickly add, remove and find elements, but when their position isn't important.

set<TYPE> NAME			// Creates a set
multiset<TYPE> NAME		// Creates a multiset
SET.insert(VALUE)		// Inserts the value into a set, notice that we don't add any parameter for the value's location
SET.erase(VALUE)		// Erases the value from a set, notice that we don't add any parameter for the value's location
________________________
Library <unordered_set>:

unordered_set<TYPE> NAME	// Creates an unordered set
unordered_multiset<TYPE> NAME	// Creates an unordered multiset
________________________________________________________________________________________________________________________________
Library <stack>:
Stacks don't support iterators. They work on the "Last in, First out" principle.

stack<TYPE> NAME		// Creates a stack
STACK.push(VALUE);		// Adds an element
STACK.pop();			// Removes the top element
STACK.top();			// Selects the top element
STACK.size();			// Returns the size of the container
STACK.empty();			// Returns true if the container is empty, or false if it's not
________________________________________________________________________________________________________________________________
Library <queue>:
Queues don't support iterators. They work on the "First in, First out" principle.
Priority queues work on the "Best First Out" principle, where the best element is by default the biggest one (it can be custom)

queue<TYPE> NAME		// Creates a queue
priority_queue<TYPE> NAME	// Creates a priority queue
QUEUE.push(VALUE);		// Adds an element
QUEUE.pop();			// Removes the top element
QUEUE.top();			// Selects the top element
QUEUE.front();			// Used for normal queues, selects the first element
QUEUE.back();			// Used for normal queues, selects the last element
QUEUE.size();			// Returns the size of the container
QUEUE.empty();			// Returns true if the container is empty, or false if it's not 
________________________________________________________________________________________________________________________________
Structures:
Structures are custom types of data which we can design to our own liking. They are made like so:

struct NAME{
	// Attributes
};
_________________________________
The variables inside of the structure are called attributes.
Note the semicolon ( ; ) after the curly brackets. 
It's placed there because we can also initialize an object of that structure's type right there:

struct STRUCTURE_NAME{
	// Attributes
} MY_STRUCTURE_1, MY_STRUCTURE_2;
_________________________________
This, however, isn't really the best way to go about things.
Since we only create objects when we need them in C++, we should create an object later on, not when we create the structure.
This creates an object called OBJECT_NAME whose type is the structure called STRUCTURE_NAME:

STRUCTURE_NAME OBJECT_NAME
_________________________________
Here's an example of how we can access a structure's attributes:

struct location{
	string country;
	string city;
	int postal_code;
	string address;
} my_college;

my_college.country = "Bosnia and Herzegowina";		// Sets the attribute "country"
my_college.city = "Sarajevo";				// Sets the attribute "city"
my_college.postal_code = 71000;				// Sets the attribute "postal_code"
my_college.address = "Zmaja od Bosne bb";		// Sets the attribute "address"
_________________________________
We can initialize all of the attributes at once if we put them inside of curly brackets in the same order like in the structure:

my_college{"Bosnia and Herzegowina", "Sarajevo", 71000, "Zmaja od Bosne bb"};
_________________________________
It's also possible to copy all contents from one object to another (assuming they're from the same structure):

my_college = my_friends_college;
_________________________________
We can also set the default values of a structure's attributes by initializing them inside of the structure with = or {}:

struct date{
	int day = 1
	int month{1}
	int year = 2000
};
_________________________________







